- مثل ما نعرف ان الفلاتر فيه دورة حياة وكذلك ال GetX يوجد فيها دورة حياة

- فبدل ما نذهب الى view ونستعمل statefullwidget ونستعمل ال initialState و dispose , فالمختصين في GetX عملوا كل الدوال هذه بداخل ال controller علشان بالفعل يتم كتابة كود نظيف.

-  فالكود الذي تكتبه في ال controller مفصول تماما عن ال view بعكس ال Provider وال Bloc اللي احيانا تعمل initialState و dispose مع ال view،
 

+++++++++++++ دوال ال lifecycle +++++++++++++

# دوال ال lifecycle التي يتم كتابتها في ال controller 
 
1- void onInit(){

    super.onInit();
 } 
وهذه بالفعل تكافى ال initialState ويتم استدعاء في بداية تشغيل البرنامج

2- void onReady(){ 

super.onReady();
}
و هذه يتم استدعاء هذه الدالة بعد ما ينعمل build للدالة


2- void onClose (){

    super.onClose();
 } 
وهذه بالفعل تكافئ ال dispose ويتم استدعاءها عندما تنحذف الصفحة من ال stack ( يعني عندما نخرج من الصفحة )
ملاحظة مهمه : أولا يتم استدعاء هذه الدالة ثم يتم حذف البيانات من ال stack اذا كانت من نوع lazyPut او GetPut في حالة ال permanent false وليست في صفحة أب...بأختصار بالبداية يتم استدعاء هذه الدالة ثم يتم الخروج من الصفحه 

+++++++++++++++ مشكلة وحلها ++++++++++++++

في دورة حياة الGetX

عند عمل Binding للتطبيق كامل ، وكانت ال instance اللي بداخل الكلاس حق ال Binding هي Get.put ,و يوجد هناك اكثر من 20 screens في التطبيق وعملنا fetch للdata من internet او ال database عند بداية تشغيل البرنامج 
باستعمال {}()onInit , هنا ممكن يتوقف ال application و وما يشتغل بسبب الكمية الهائلة من البيانات التي سوف يؤتى بيها من ال internet or database  

# الحل

- بدل ما نستخدم ال instance Get.put في كلاس ال Binding نستخدم ال Get.lazyPut مع fenix



# ملاحظه مهمه جدا 

- في حالة عندنا lifecycle في ال Controller دائما وأنت عم تعمل Binding على مستوى ال application فدائما حاول تستعمل ال Get.lazyPut وما تستعمل ال Get.put الا إذا الفكرة اللي أنت تريدها تحتاج هذا الموضوع( استدعاء كل البيانات من كل الصفحات في بداية تشغيل البرنامج )

++++++++++++++++++++++++++++++++++++++
